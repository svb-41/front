{
  "assault": "import * as svb from '@svb-41/core'\nconst { dist2 } = svb.helpers\n\ntype Data = { initialDir?: number }\ntype ControllerArgs = svb.controller.ControllerArgs<Data>\nconst FIRE = svb.controller.Instruction.FIRE\n\nexport const initialData: Data = {}\nexport default ({ stats, radar, memory, ship }: ControllerArgs) => {\n  if (!memory.initialDir) memory.initialDir = stats.position.direction\n  if (stats.position.speed < 0.1) return ship.thrust()\n\n  const ally = radar.find(res => {\n    const isSameTeam = res.team === stats.team\n    if (!isSameTeam) return false\n    const source = stats.position\n    const target = svb.helpers.nextPosition(200)(res.position)\n    const finalAngle = svb.helpers.angle({ source, target })\n    const direction = finalAngle - stats.position.direction\n    return Math.abs(direction) < 0.1\n  })\n\n  const closeEnemy = radar\n    .filter(res => res.team !== stats.team && !res.destroyed)\n    .map(res => ({ res, dist: dist2(res.position, stats.position) }))\n\n  if (closeEnemy.length > 0) {\n    const nearestEnemy = closeEnemy.reduce((a, v) => (a.dist > v.dist ? v : a))\n    const source = stats.position\n    const target = nearestEnemy.res.position\n    const threshold = 4 / Math.sqrt(nearestEnemy.dist)\n    const speed = stats.weapons[0]?.bullet.position.speed\n    const delay = Math.sqrt(nearestEnemy.dist) / speed\n    const resAim = svb.helpers.aim({ ship, source, target, threshold, delay })\n    if (resAim.id === FIRE && ally) return ship.idle()\n    return resAim\n  }\n\n  if (memory.initialDir - stats.position.direction)\n    return ship.turn(memory.initialDir - stats.position.direction)\n  return ship.idle()\n}\n",
  "hold": "import * as svb from '@svb-41/core'\nconst { dist2 } = svb.helpers\n\ntype Data = {}\ntype ControllerArgs = svb.controller.ControllerArgs<Data>\nconst FIRE = svb.controller.Instruction.FIRE\n\nexport default ({ stats, radar, ship }: ControllerArgs) => {\n  const ally = radar.find(res => {\n    const isSameTeam = res.team === stats.team\n    if (!isSameTeam) return false\n    const source = stats.position\n    const target = svb.helpers.nextPosition(200)(res.position)\n    const finalAngle = svb.helpers.angle({ source, target })\n    const direction = finalAngle - stats.position.direction\n    return Math.abs(direction) < 0.1\n  })\n\n  const closeEnemy = radar\n    .filter(res => res.team !== stats.team && !res.destroyed)\n    .map(res => ({ res, dist: dist2(res.position, stats.position) }))\n\n  if (closeEnemy.length > 0) {\n    const nearestEnemy = closeEnemy.reduce((a, v) => (a.dist > v.dist ? v : a))\n    const source = stats.position\n    const target = nearestEnemy.res.position\n    const threshold = 1 / Math.sqrt(nearestEnemy.dist)\n    const speed = stats.weapons[0].bullet.position.speed\n    const delay = Math.sqrt(nearestEnemy.dist) / speed\n    const resAim = svb.helpers.aim({ ship, source, target, threshold, delay })\n    if (resAim.id === FIRE && ally) return ship.idle()\n    return resAim\n  }\n\n  return ship.idle()\n}\n",
  "mine": "import * as svb from '@svb-41/core'\nconst { dist2 } = svb.helpers\n\ntype Data = { targets: Array<{ x: number; y: number }> }\ntype ControllerArgs = svb.controller.ControllerArgs<Data>\n\nconst t = (x: number, y: number) => ({ x, y })\nconst targets = [t(500, 300), t(500, 500), t(500, 700), t(500, 700)]\nexport const initialData = { targets }\nexport default ({ stats, radar, memory, ship }: ControllerArgs) => {\n  if (radar.length > 0) {\n    const closeEnemy = radar\n      .filter(res => res.team !== stats.team && !res.destroyed)\n      .map(res => ({ res, dist: dist2(res.position, stats.position) }))\n    if (closeEnemy.length > 0) {\n      const nearEnmy = closeEnemy.reduce((a, v) => (a.dist > v.dist ? v : a))\n      if (nearEnmy) {\n        const dist = Math.sqrt(nearEnmy.dist) / 0.6\n        const target = svb.helpers.nextPosition(dist)(nearEnmy.res.position)\n        return ship.fire(stats.weapons[0].coolDown === 0 ? 0 : 1, {\n          target: target.pos,\n          armedTime: nearEnmy.dist - 100,\n        })\n      }\n    }\n  }\n  if (stats.weapons[2].coolDown === 0 && memory.targets.length > 0)\n    return ship.fire(2, { target: memory.targets.pop(), armedTime: 500 })\n  return ship.idle()\n}\n",
  "scout": "import * as svb from '@svb-41/core'\nconst { dist2 } = svb.helpers\n\ntype Data = { initialDir?: number }\ntype ControllerArgs = svb.controller.ControllerArgs<Data>\n\nexport const initialData = {}\nexport default ({ stats, memory, comm, radar, ship }: ControllerArgs) => {\n  if (!memory.initialDir) memory.initialDir = stats.position.direction\n  if (stats.position.speed < 0.08) return ship.thrust()\n  if (radar.length > 0) {\n    const enemies = radar\n      .filter(res => res.team !== stats.team && !res.destroyed)\n      .map(res => res.position)\n    if (enemies.length > 0) comm.sendMessage(enemies)\n    const importantTarget = radar\n      .filter(res => res.team !== stats.team && !res.destroyed)\n      .find(enemy => enemy.size === 16)\n    if (importantTarget) {\n      const targetDist = dist2(stats.position, importantTarget.position)\n      return svb.helpers.aim({\n        ship,\n        source: stats.position,\n        target: importantTarget!.position,\n        threshold: 4 / Math.sqrt(targetDist),\n        delay: Math.sqrt(targetDist) / stats.weapons[0]?.bullet.position.speed,\n      })\n    }\n  }\n  if (memory.initialDir - stats.position.direction === 0) return ship.idle()\n  return ship.turn(memory.initialDir - stats.position.direction)\n}\n",
  "torpedo": "import * as svb from '@svb-41/core'\nconst { dist2 } = svb.helpers\n\ntype Position = svb.ship.Position\ntype Data = { targets: Array<Position> }\ntype ControllerArgs = svb.controller.ControllerArgs<Data>\n\nexport const initialData: Data = { targets: [] }\nexport default ({ stats, radar, memory, ship, comm }: ControllerArgs) => {\n  const messages = comm.getNewMessages()\n  if (radar.length > 0) {\n    const closeEnemy = radar\n      .filter(res => res.team !== stats.team && !res.destroyed)\n      .map(res => ({ res, dist: dist2(res.position, stats.position) }))\n\n    if (closeEnemy.length > 0) {\n      const nearEnmy = closeEnemy.reduce((a, v) => (a.dist > v.dist ? v : a))\n      if (nearEnmy) {\n        const dist = Math.sqrt(nearEnmy.dist) / 0.6\n        const target = svb.helpers.nextPosition(dist)(nearEnmy.res.position)\n        return ship.fire(stats.weapons[0].coolDown === 0 ? 0 : 1, {\n          target: target.pos,\n          armedTime: nearEnmy.dist - 100,\n        })\n      }\n    }\n  }\n\n  if (messages.length > 0) {\n    const targets = messages\n      .map(m => m.content.message.map((res: any) => res))\n      .reduce((acc, val) => [...acc, ...val]) as Array<Position>\n    memory.targets = targets\n  }\n\n  if (memory.targets.length > 0 && stats.weapons[1].coolDown === 0) {\n    const target = svb.helpers.nextPosition(200)(memory.targets.pop()!)\n    const d = Math.sqrt(dist2(stats.position, target))\n    return ship.fire(1, { target: target.pos, armedTime: d - 100 })\n  }\n\n  return ship.idle()\n}\n"
}
